<style>body {font-family: verdana}</style>
<h1>Creating a JavaScriptMVC widget.</h1>

<p>JavaScriptMVC is makes it easier to 
write and organize copious amounts of JavaScript code.  
And although this usually means working among its 
Model-View-Controller layers to create something amazing; 
often, you'll find yourself wanting to make a lightweight, 
reusable UI widget.  This demo walks you 
through creating a basic slider widget.</p>

<h2>Demo</h2>

<p><a href='http://javascriptmvc.com/mxui/slider/slider.html'>Mxui slider</a> &lt;- what we are making</p>

<h2>Step 1:  Creating a widget play-place.</h2>
<p>For the vast majority of applications we build, 
we have 2 root folders:</p>
</p>
<ul>
	<li>
		<p>The application folder</p>
		<p>Has all the files and tests specific to the 
			application: models, business logic controllers, 
			and views, used to customize the output of reusable widgets.</p>
	</li>
	<li>
		<p>The widget folder</p>
		<p>Has all the potentially reusable widgets.  These are things that can be used outside a specific application. For Jupiter, we've been putting all of these in mxui, 
			<a href='http://github.com/jupiterjs/mxui'>the jQueryMX UI library</a>.</p>
	</li>
</ul>

<p>The first step of creating a widget is creating the 
folder and files our widget needs.  
Fortunately, the 
<code>jquery/generate/plugin</code> generator 
does this.  By typing the following in the command line, it creates a page, empty source file, and tests for our widget.
</p>
<pre><code>js jquery/generate/plugin mxui/slider</code></pre>


<h2>Step 2: Creating the API and test page.</h2>

<p>Before you can write tests for a UI widget, it helps
to know what you're going to test.  So, the first step
is to create a test page and design the widget's API.</p>
<p>Designing an API is a subtle and tricky business.
 Try to keep things as simple as possibly by only building the
 'essence' of a widget.  
For me, it's just a draggable element who's
value changes based on it's position relative to
its container.  The slider will read the container's 
properties and set itself up accordingly.</p>
<p>This is in contrast to 
something like 
<a href='http://jqueryui.com/demos/slider/'>jQueryUI's</a>
or <a href='http://developer.yahoo.com/yui/examples/slider/slider_dual_thumb.html'>YUI's</a> 
slider, where the slider control includes the 
containing element, and mandates other conventions (like specific classNames).
</p>
<p>By focusing on just the basics, our slider will be 
lightweight and more flexible.
</p>

<p>So, to our test page, I'll add a minimal HTML structure 
for the slider, some CSS, and an element to show the value of the slider:
</p>
<p><b>The HTML:</b></p>
<pre><code class='xml'>&lt;div id='container'>
  &lt;div id='slider'>&lt;/div>
&lt;/div>
&lt;input id='value'/></code></pre>

<p><b>The CSS:</b></p>
<pre><code>#container {
  width: 330px;
  border: solid 1px black;
}
#slider {
  width: 26px;
  border: solid 2px green;
  background-color: #008000;
  height: 30px;
}
</code></pre>
<p>Finally, I want to setup my 
slider and listen for changes on it.  
So I add the following in a script tag:</p>

<pre><code>$("#slider").mxui_slider({
  min: 1,  // the minimum value
  max: 10, // the maximum value
  val: 5   // the starting value
}).change(function(ev, value){
  // show the value
  $('#value').val(value)
});</code></pre>
<p>You can see the result of these pages 
   in <a href='https://github.com/jupiterjs/mxui/blob/master/slider/slider.html'>slider.html</a>.
   Now we have something we can test!
   
</p>


<h2>Step 3: Creating a test.</h2>

<p>The generator produces a test script in 
<a href='https://github.com/jupiterjs/mxui/blob/master/slider/test/funcunit/slider_test.js'><code>mxui/slider/test/funcunit/slider_test.js</code></a>.
I'll add the following tests:</p>

<pre><code>test("dragging changes value",function(){
  S("#slider").drag("+30 +0", function(){
    equals( S("#value").val(), 6);
  }).drag("-60 +0",function(){
    equals( S("#value").val(), 4);
  });
})</code></pre>

<pre><code>test("dragging out of bounds", function(){
  S("#slider").drag("+400 +0", function(){
    equals( S("#value").val(), 10);
  }).drag("-400 +0", function(){
    equals( S("#value").val(), 1);
  })
})</code></pre>

<p><a href='http://funcunit.com'>FuncUnit's</a> syntax is so awesome, I'm not going to explain what these do.
   If I were making this slider for more than a demo, I'd also add quite a few more tests.  But
   this is a good start.
</p>

<p>If we run these tests, it fails miserably.  So, lets move to building the slider!</p>

<h2>Step 4: Creating the slider plugin:</h2>

<p>I'll build the plugin in steps that paralleled how I 
actually built the widget.  </p>
<h3>Setup the slider widget</h3>
<p>
The first thing I'll do is open 
<a href='https://github.com/jupiterjs/mxui/blob/master/slider/slider.js'>slider.js</a> 
and steal the two plugins I'm certain are needed:</p>

<pre><code>steal.plugins('jquery/controller',
              'jquery/event/drag')
     .then(function($){</code></pre>

<p>Then I define my slider widget:</p>

<pre><code>$.Controller("Mxui.Slider",{})</code></pre>
<h3>Configuring the drag behavior</h3>
<p>I want my element to be draggable, so I'll make a draginit function:</p>

<pre><code>$.Controller("Mxui.Slider",{
  "draginit" : function(el, ev, drag){}
});</code></pre>

<p>At this point, I can start dragging my element around the page.  
But, I want to keep the element in its container.  JavaScriptMVC 
has a drag limit plugin that does exactly this.  So I'll add 
<code>'jquery/event/drag/limit'</code> to the list of steal.plugins and make draginit look like:</p>

<pre><code>"draginit" : function(el, ev, drag){
  drag.limit(this.element.parent())
}</code></pre>

<p>At this point, my drag can't escape it's parent.  
With the following 5 lines, we've got something that 
looks very much like a slider:</p>

<pre><code>$.Controller("Mxui.Slider",{
  "draginit" : function(el, ev, drag){
    drag.limit(this.element.parent())
  }
});</code></pre>

<p>I also want my slider to snap in increments.  
The <code>jquery/event/drag/step</code> plugin 
limits a drag's position to every X pixels relative to some container.  
This is perfect!  The only problem is that I need to know that pixel value.  
To help, I'll create a 
getDimensions function 
that gets and caches this and other values:</p>

<pre><code>getDimensions : function(){
  var spots = this.options.max - this.options.min,
      parent = this.element.parent();
  
  //total movable area
  this.widthToMove = parent.width() - 
                     this.element.outerWidth();
  
  //space between spots
  this.widthOfSpot = this.widthToMove / 
                     this.options.spots;
}</code></pre>
<p>The following diagram might help these calculations make sense:</p>

<p><code>$.Controller</code>
creates a jQuery plugin.  In this case, it creates
<code>$().mxui_slider()</code>.  The first argument passed to the 
mxui_slider becomes this.options on the controller.  
I used the min and max values, the width of the container element, 
and the outer width of the slider to calculate the width of one spot.
</p>
<p>  
Now in draginit, I call getDimensions and use the spot width to set the step value:</p>

<pre><code>  "draginit" : function(el, ev, drag){
    drag.limit(this.element.parent())
        .step(this.widthOfSpot, this.element.parent());
  }</cod></pre>
<h3>Calculating and sharing the value</h3>
<p>I want my slider to behave similar to a form element. 
When it's value changes (a drag motion is complete), it will trigger a change event 
with the value of the slider.  
</p>
<p>To do this, I need to know 
where the draggable is in relation to the 
inner left side of the container.  I'll calculate this in getDimensions with JavaScriptMVC's 
<a href='http://jupiterjs.com/news/get-multiple-computed-styles-fast-with-the-curstyles-jquery-plugin'>curStyles</a> plugin:</p>
<pre><code>  var styles = parent.curStyles("borderLeftWidth",
                                "paddingLeft"),
      leftSpace = parseInt( styles.borderLeftWidth ) + 
                  parseInt( styles.paddingLeft )|| 0;
  this.leftStart = parent.offset().left + spaceLeft;</code></pre>

<p>Now, I can listen for dragend, calculate the value the 
draggable, and trigger a change event with the value:</p>

<pre><code>  "dragend" : function(el, ev, drag){
    var left =  this.element.offset().left - this.leftStart;
    var spot = Math.round( left / this.widthOfSpot );
    this.element.trigger("change", spot+this.options.min)
  }</code></pre>
		
<p>I also want to be able to get the value of the slider pragmatically like:</p>
<pre><code>$('#slider').mxui_slider('val') -> '5'</code></pre>

<p>And be able to set the value (and update the UI) like:</p>

<pre><code>$('#slider').mxui_slider('val',7);</code></pre>

<p>To do this, I'll add a val function to my controller like:</p>

<pre><code>  val : function(value){
    this.getDimensions();
    if(value){
      //move slider into place
      this.element.offset({
        left: this.leftStart+
                Math.round( (value-this.options.min)
                  *this.widthOfSpot )
      })
      this.element.trigger("change", value)
    }else{
      var left = this.element.offset().left - 
                 this.spaceLeft;
      return Math.round( this.leftStart/this.widthOfSpot)+
             this.options.min;
    }
  }</code></pre>

<h4>Model <-> View binding</h4>
<p>As a quick side note, this plugin can now work with the 'jquery/tie' 
plugin so you can have bi-directional binding between models 
and sliders.  For example:</p>

<pre><code>$.Model('Person')
person  = new Person({age : 7})
$('#slider').mxui_slider({min: 0, max: 10}).tie(person, "age")</code></pre>


<p>This allows us to change the value of person and it will 
automatically update the slider and vice versa. 
See an example <a href='http://javascriptmvc.com/jquery/tie/tie.html'>here</a>.</p>

<h3>Accept an initial value</h3>
<p>We want to be able to initialize our controller 
with a value.  We will do by adding an init that sets an inital value if provided:</p>

<pre><code>  init : function(){
    this.element.css({
  	position: 'relative'
    })
    if(this.options.val){
      this.val(this.options.val)
    }
  }</code></pre>

<h3>Default options</h3>
<p>Finally, we want to make our plugin as easy to initalize as 
possible so we give it default option values like:</p>

<pre><code>$.Controller("Mxui.Slider",{
  defaults : {
    min: 0,
    max: 10
  }
},
{ ... });</code></pre>

<h2>Conclusion</h2>
<p>This example is meant to touch on a few key concepts:
</p>
<ul>
	<li>Test driven development of traditionally difficult to test UI behavior.</li>
	<li>High-level JavaScriptMVC organization.</li>
	<li>Widget design.</li>
	<li>Using drag events and controller.</li>
</ul>

<p>But most importantly, it might make you less afraid to write your own widgets. 

There's room for improvement.  For example, it shouly only trigger a change if 
the value changes.  However, in only 53 lines, we've made halfway decent slider that covers
95% of what most apps need.
</p>


